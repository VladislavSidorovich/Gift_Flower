<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–¶–≤–µ—Ç–æ—á–∫–∏ üå∏</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./style/style.css">
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>
    <div class="clean-btn">–ù–∞–∂–º–µ—à—å –∏ –≤—Å–µ –æ—á–∏—Å—Ç–∏—Ç—å—Å—è</div>
  </div>
  <div class="name">–ù–∞–∂–º–µ—à—å –∏ —É–≤–∏–¥–µ—à—å –∫—Ä–∞—Å–æ—Ç—É</div>
  <audio id="bg-music" autoplay loop>
    <source src="./style/KhuRungDomDom.mp3" type="audio/mpeg">
  </audio>

 <script type="x-shader/x-fragment" id="fragmentShader">
#define PI 3.14159265359

uniform float u_ratio;
uniform vec2 u_cursor;
uniform float u_stop_time;
uniform float u_clean;
uniform vec2 u_stop_randomizer;

uniform sampler2D u_texture;
varying vec2 vUv;

// --------------------------------
// 2D noise

vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–µ–π –Ω–∞ –∫—Ä–∞—è—Ö –ª–µ–ø–µ—Å—Ç–∫–æ–≤
float get_petal_jaggedness(vec2 p, float petal_angle, float frequency) {
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —à—É–º–∞
    float jagged = snoise(p * 15.0) * 0.08;
    jagged += snoise(p * 25.0 + vec2(2.0, 3.0)) * 0.05;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–∏
    jagged += sin(petal_angle * frequency * 4.0) * 0.03;
    jagged += cos(petal_angle * frequency * 6.0 + 1.5) * 0.02;
    
    return jagged;
}

// –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –§–û–†–ú–´ –¶–í–ï–¢–ö–ê (–∏–∑ –ø–µ—Ä–≤–æ–≥–æ —à–µ–π–¥–µ—Ä–∞)
float get_flower_shape_improved(vec2 _p, float _pet_n, float _angle, float _outline) {
    _angle *= 3.;

    _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle),
            _p.x * sin(_angle) + _p.y * cos(_angle));

    float a = atan(_p.y, _p.x);
    float dist = length(_p);

    // –°–æ–∑–¥–∞–µ–º —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω—É—é —Ñ–æ—Ä–º—É —Å –º–µ–Ω—å—à–µ–π —Å—Ç–æ—Ä–æ–Ω–æ–π —É –æ—Å–Ω–æ–≤–∞–Ω–∏—è
    float trapezoid_factor = 1.0 - smoothstep(0.0, 0.5, dist) * 0.4;
    float petal_width = pow(abs(sin(a * _pet_n)), 0.4) * trapezoid_factor;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–∏ –∫ —Ñ–æ—Ä–º–µ –ª–µ–ø–µ—Å—Ç–∫–æ–≤
    float jaggedness = get_petal_jaggedness(_p, a * _pet_n, _pet_n);
    petal_width += jaggedness;

    // –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±—É—Ç–æ–Ω–∞ –≤ 2 —Ä–∞–∑–∞
    vec2 flower_size_range = vec2(.09, .1);
    float size = flower_size_range[0] + u_stop_randomizer[0] * flower_size_range[1];

    // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ä–∞–¥–∏–∞–ª—å–Ω—É—é —Ñ–æ—Ä–º—É –¥–ª—è —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–æ—Å—Ç–∏
    float base_shape = dist / size;
    
    // –î–µ–ª–∞–µ–º –ª–µ–ø–µ—Å—Ç–∫–∏ —É–∂–µ —É –æ—Å–Ω–æ–≤–∞–Ω–∏—è (—Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–∞—è —Ñ–æ—Ä–º–∞)
    float taper = 1.0 + smoothstep(0.0, 0.7, base_shape) * 0.5;
    base_shape *= taper;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –±–æ–ª—å—à–µ –Ω–µ—Ä–æ–≤–Ω–æ—Å—Ç–µ–π
    base_shape += get_petal_jaggedness(_p, a, 8.0) * 0.3;
    base_shape = pow(base_shape, 2.0);
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –ª–µ–ø–µ—Å—Ç–∫–æ–≤
    float surface_texture = snoise(_p * 30.0) * 0.05;
    base_shape += surface_texture;

    float grow_time = step(.25, u_stop_time) * pow(u_stop_time, .3);
    float flower_shape = 1.0 - smoothstep(0.0, petal_width + 0.25, _outline * base_shape / grow_time);

    flower_shape *= (1. - step(1., grow_time));

    return flower_shape;
}

// –û–†–ò–ì–ò–ù–ê–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –§–û–†–ú–´ –¶–í–ï–¢–ö–ê (–∏–∑ –≤—Ç–æ—Ä–æ–≥–æ —à–µ–π–¥–µ—Ä–∞)
float get_flower_shape_original(vec2 _p, float _pet_n, float _angle, float _outline) {
    _angle *= 3.;

    _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle),
            _p.x * sin(_angle) + _p.y * cos(_angle));

    float a = atan(_p.y, _p.x);

    float flower_sectoral_shape = pow(abs(sin(a * _pet_n)), .4) + .25;

    vec2 flower_size_range = vec2(.03, .1);
    float size = flower_size_range[0] + u_stop_randomizer[0] * flower_size_range[1];

    float flower_radial_shape = pow(length(_p) / size, 2.);
    flower_radial_shape -= .1 * sin(8. * a); // add noise
    flower_radial_shape = max(.1, flower_radial_shape);
    flower_radial_shape += smoothstep(0., 0.03, -_p.y + .2 * abs(_p.x));

    float grow_time = step(.25, u_stop_time) * pow(u_stop_time, .3);
    float flower_shape = 1. - smoothstep(0., flower_sectoral_shape, _outline * flower_radial_shape / grow_time);

    flower_shape *= (1. - step(1., grow_time));

    return flower_shape;
}

float get_stem_shape(vec2 _p, vec2 _uv, float _w, float _angle) {
    _w = max(.004, _w);
    
    float x_offset = _p.y * sin(_angle);
    x_offset *= pow(3. * _uv.y, 2.);
    _p.x -= x_offset;

    // add horizontal noise to the cursor coordinale
    float noise_power = .5;
    float cursor_horizontal_noise = noise_power * snoise(2. * _uv * u_stop_randomizer[0]);
    cursor_horizontal_noise *= pow(dot(_p.y, _p.y), .6);// moise to be zero at cursor
    cursor_horizontal_noise *= pow(dot(_uv.y, _uv.y), .3);// moise to be zero at bottom
    _p.x += cursor_horizontal_noise;

    // vertical line through the cursor point (_p.x)
    float left = smoothstep(-_w, 0., _p.x);
    float right = 1. - smoothstep(0., _w, _p.x);
    float stem_shape = left * right;

    // make it grow + don't go up to the cursor point
    float grow_time = 1. - smoothstep(0., .2, u_stop_time);
    float stem_top_mask = smoothstep(0., pow(grow_time, .5), .03 -_p.y);
    stem_shape *= stem_top_mask;

    // stop drawing once done
    stem_shape *= (1. - step(.17, u_stop_time));

    return stem_shape;
}

void main() {
    vec3 base = texture2D(u_texture, vUv).xyz;

    vec2 uv = vUv;
    uv.x *= u_ratio;
    vec2 cursor = vUv - u_cursor.xy;
    cursor.x *= u_ratio;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–æ–π —Ç–∏–ø —Ü–≤–µ—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
    float flower_type_selector = mod(u_stop_randomizer[1] * 10.0, 5.0);
    
    // –°—Ç–µ–±–ª–∏ –∑–µ–ª–µ–Ω—ã–µ
    vec3 stem_color = vec3(0.3, 0.6 + u_stop_randomizer[0] * 0.2, 0.25); // –ù–µ–∂–Ω–æ-–∑–µ–ª–µ–Ω—ã–π

    float angle = .5 * (u_stop_randomizer[0] - .5);

    float stem_shape = get_stem_shape(cursor, uv, .003, angle);
    stem_shape += get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .003, angle);
    float stem_mask = 1. - get_stem_shape(cursor, uv, .004, angle);
    stem_mask -= get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .004, angle);

    float petals_back_number = 1. + floor(u_stop_randomizer[0] * 2.);
    float angle_offset = -(2. * step(0., angle) - 1.) * .1 * u_stop_time;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Ü–≤–µ—Ç–∫–æ–≤ –¥–ª—è –∑–∞–¥–Ω–µ–≥–æ –∏ –ø–µ—Ä–µ–¥–Ω–µ–≥–æ –ø–ª–∞–Ω–∞
    float flower_back_shape, flower_front_shape;
    float flower_back_mask, flower_front_mask;
    
    if (flower_type_selector < 1.0) {
        // –£–ª—É—á—à–µ–Ω–Ω—ã–µ —Ü–≤–µ—Ç—ã (–ø–µ—Ä–≤—ã–π —Ç–∏–ø)
        flower_back_shape = get_flower_shape_improved(cursor, petals_back_number, angle + angle_offset, 1.5);
        flower_back_mask = 1. - get_flower_shape_improved(cursor, petals_back_number, angle + angle_offset, 1.6);
        
        float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
        flower_front_shape = get_flower_shape_improved(cursor, petals_front_number, angle, 1.);
        flower_front_mask = 1. - get_flower_shape_improved(cursor, petals_front_number, angle, .95);
    } else {
        // –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ü–≤–µ—Ç—ã (–≤—Ç–æ—Ä–æ–π —Ç–∏–ø)
        flower_back_shape = get_flower_shape_original(cursor, petals_back_number, angle + angle_offset, 1.5);
        flower_back_mask = 1. - get_flower_shape_original(cursor, petals_back_number, angle + angle_offset, 1.6);
        
        float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
        flower_front_shape = get_flower_shape_original(cursor, petals_front_number, angle, 1.);
        flower_front_mask = 1. - get_flower_shape_original(cursor, petals_front_number, angle, .95);
    }

    vec3 color = base;
    
    // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ —Å—Ç–µ–±–µ–ª—å —Ä–∏—Å—É–µ—Ç—Å—è –ü–û–î —Ü–≤–µ—Ç–∫–æ–º
    color *= stem_mask;
    color += (stem_shape * stem_color);
    
    // –¢–µ–ø–µ—Ä—å —Ä–∏—Å—É–µ–º —Ü–≤–µ—Ç–æ–∫ –ø–æ–≤–µ—Ä—Ö —Å—Ç–µ–±–ª—è
    color *= flower_back_mask;
    color *= flower_front_mask;

    // 10 –≤–∞—Ä–∏–∞—Ü–∏–π —Ü–≤–µ—Ç–æ–≤ –¥–ª—è –±—É—Ç–æ–Ω–æ–≤
    float flower_type = mod(u_stop_randomizer[1] * 30.0, 30.0);
    vec3 flower_color;

if (flower_type < 1.0) {
    flower_color = vec3(0.95, 0.7, 0.9); // –ù–µ–∂–Ω–æ-—Ä–æ–∑–æ–≤—ã–π (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 2.0) {
    flower_color = vec3(0.8, 0.7, 0.95); // –°–∏—Ä–µ–Ω–µ–≤—ã–π (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 3.0) {
    flower_color = vec3(0.7, 0.8, 0.95); // –ì–æ–ª—É–±–æ–≤–∞—Ç—ã–π (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 4.0) {
    flower_color = vec3(0.95, 0.8, 0.7); // –ü–µ—Ä—Å–∏–∫–æ–≤—ã–π (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 5.0) {
    flower_color = vec3(0.9, 0.95, 0.7); // –°–∞–ª–∞—Ç–æ–≤—ã–π (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 6.0) {
    flower_color = vec3(0.85, 0.7, 0.9); // –û—Ä—Ö–∏–¥–µ—è (–±–µ–ª–∞—è –æ—Å–Ω–æ–≤–∞)
} else if (flower_type < 7.0) {
    flower_color = vec3(0.9, 0.5, 0.7); // –Ø—Ä–∫–∏–π —Ä–æ–∑–æ–≤–æ-–∫—Ä–∞—Å–Ω—ã–π
} else if (flower_type < 8.0) {
    flower_color = vec3(0.6, 0.8, 0.4); // –Ø—Ä–∫–∏–π –ª–∞–π–º–æ–≤–æ-–∑–µ–ª–µ–Ω—ã–π
} else if (flower_type < 9.0) {
    flower_color = vec3(0.5, 0.7, 0.9); // –Ø—Ä–∫–∏–π —Å–∏–Ω–µ-–≥–æ–ª—É–±–æ–π
} else if (flower_type < 10.0) {
    flower_color = vec3(0.9, 0.6, 0.4); // –Ø—Ä–∫–∏–π –æ—Ä–∞–Ω–∂–µ–≤–æ-–∫–æ—Ä–∞–ª–ª–æ–≤—ã–π
} else if (flower_type < 11.0) {
    flower_color = vec3(0.7, 0.4, 0.9); // –Ø—Ä–∫–∏–π —Ñ–∏–æ–ª–µ—Ç–æ–≤–æ-–ø—É—Ä–ø—É—Ä–Ω—ã–π
} else if (flower_type < 12.0) {
    flower_color = vec3(0.4, 0.9, 0.6); // –Ø—Ä–∫–∏–π –∑–µ–ª–µ–Ω–æ-–±–∏—Ä—é–∑–æ–≤—ã–π
} else if (flower_type < 13.0) {
    flower_color = vec3(0.9, 0.8, 0.3); // –Ø—Ä–∫–∏–π –∂–µ–ª—Ç–æ-–ø–µ—Ä—Å–∏–∫–æ–≤—ã–π
} else if (flower_type < 14.0) {
    flower_color = vec3(0.3, 0.6, 0.9); // –Ø—Ä–∫–∏–π —Å–∏–Ω–µ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
} else if (flower_type < 15.0) {
    flower_color = vec3(0.9, 0.4, 0.6); // –Ø—Ä–∫–∏–π —Ñ—É–∫—Å–∏—è
} else if (flower_type < 16.0) {
    flower_color = vec3(0.5, 0.9, 0.8); // –Ø—Ä–∫–∏–π –±–∏—Ä—é–∑–æ–≤–æ-–∑–µ–ª–µ–Ω—ã–π
} else if (flower_type < 17.0) {
    flower_color = vec3(0.8, 0.3, 0.9); // –Ø—Ä–∫–∏–π –ø—É—Ä–ø—É—Ä–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π
} else if (flower_type < 18.0) {
    flower_color = vec3(0.9, 0.7, 0.2); // –Ø—Ä–∫–∏–π –æ—Ä–∞–Ω–∂–µ–≤–æ-–∂–µ–ª—Ç—ã–π
} else if (flower_type < 19.0) {
    flower_color = vec3(0.2, 0.8, 0.9); // –Ø—Ä–∫–∏–π –≥–æ–ª—É–±–æ-—Å–∏–Ω–∏–π
} else if (flower_type < 20.0) {
    flower_color = vec3(0.9, 0.5, 0.8); // –Ø—Ä–∫–∏–π —Ä–æ–∑–æ–≤–æ-–ø—É—Ä–ø—É—Ä–Ω—ã–π
} else if (flower_type < 21.0) {
    flower_color = vec3(0.6, 0.9, 0.5); // –Ø—Ä–∫–∏–π –∑–µ–ª–µ–Ω—ã–π –ª–∞–π–º
} else if (flower_type < 22.0) {
    flower_color = vec3(0.4, 0.5, 0.9); // –Ø—Ä–∫–∏–π —Å–∏–Ω–∏–π –∫–æ–±–∞–ª—å—Ç
} else if (flower_type < 23.0) {
    flower_color = vec3(0.9, 0.6, 0.5); // –Ø—Ä–∫–∏–π –∫–æ—Ä–∞–ª–ª–æ–≤–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
} else if (flower_type < 24.0) {
    flower_color = vec3(0.7, 0.9, 0.4); // –Ø—Ä–∫–∏–π –∂–µ–ª—Ç–æ-–∑–µ–ª–µ–Ω—ã–π
} else if (flower_type < 25.0) {
    flower_color = vec3(0.8, 0.7, 0.9); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π —Å–∏—Ä–µ–Ω–µ–≤—ã–π
} else if (flower_type < 26.0) {
    flower_color = vec3(0.7, 0.9, 0.8); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π –º—è—Ç–Ω—ã–π
} else if (flower_type < 27.0) {
    flower_color = vec3(0.9, 0.8, 0.7); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π –ø–µ—Ä—Å–∏–∫–æ–≤—ã–π
} else if (flower_type < 28.0) {
    flower_color = vec3(0.8, 0.8, 0.9); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π –ª–∞–≤–∞–Ω–¥–æ–≤—ã–π
} else if (flower_type < 29.0) {
    flower_color = vec3(0.9, 0.7, 0.8); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π —Ä–æ–∑–æ–≤—ã–π
} else {
    flower_color = vec3(0.7, 0.8, 0.9); // –ü–∞—Å—Ç–µ–ª—å–Ω—ã–π –≥–æ–ª—É–±–æ–π
}

    // –î–æ–±–∞–≤–ª—è–µ–º —Ü–≤–µ—Ç –¢–û–õ–¨–ö–û –∫ –±—É—Ç–æ–Ω–∞–º
    color += (flower_back_shape * flower_color);
    color += (flower_front_shape * flower_color);

    // –£—Å–∏–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –ª–µ–ø–µ—Å—Ç–∫–æ–≤ (—Ç–æ–ª—å–∫–æ –¥–ª—è —É–ª—É—á—à–µ–Ω–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤)
    if (flower_type_selector < 1.0) {
        float texture_strength = snoise(cursor * 50.0) * 0.1;
        vec3 textured_flower = mix(color, flower_color * 1.2, 
                                  (flower_back_shape + flower_front_shape) * texture_strength);
        color = mix(color, textured_flower, flower_back_shape + flower_front_shape);
    }

    // –ë–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ü–≤–µ—Ç–æ–≤—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã
    color.r *= 1. - (.3 * flower_back_shape * flower_front_shape);
    color.b *= 1. - (.4 * flower_back_shape * flower_front_shape);

    color *= u_clean;

    gl_FragColor = vec4(color, 1.);
}
</script>
  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.);
    }
  </script>
  <script type="module" src="./style/module.js"></script>
  <script src="./style/script.js"></script>
</body>
</html>

